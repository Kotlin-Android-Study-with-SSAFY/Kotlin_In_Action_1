# 📌 5.3 지연 계산(Lazy) 컬렉션 연산

## ✅ 즉시 실행 vs 지연 실행

### 🔹 즉시 실행(Eager Evaluation)이란?

기본적으로 `map`이나 `filter` 같은 컬렉션 연산은 **즉시 실행 방식**으로 동작한다. 즉, 각 연산이 수행될 때마다 새로운 리스트를 생성하여 결과를 저장한다.

```kotlin
val people = listOf(Person("Alice", 29), Person("Bob", 31), Person("Charles", 31), Person("Dan", 21))

val names = people.map { it.name }.filter { it.startsWith("A") }
println(names) // [Alice]

```

🔹 위 코드의 문제점:

- `map { it.name }`을 실행하면 **새로운 리스트가 생성**됨.
- `filter { it.startsWith("A") }`을 실행할 때 또 **새로운 리스트가 생성**됨.
- 즉, 중간 결과를 저장하는 **불필요한 리스트가 계속 만들어짐** → **비효율적!** 🚨

---

### 🔹 지연 실행(Lazy Evaluation)이란?

**시퀀스(Sequence)** 를 사용하면 이러한 **중간 컬렉션을 생성하지 않고도 연산을 연쇄적으로 적용할 수 있다.**

```kotlin
val namesLazy = people.asSequence()
    .map { it.name }
    .filter { it.startsWith("A") }
    .toList()

println(namesLazy) // [Alice]

```

🔹 **어떤 차이가 있을까?**

- `asSequence()`를 사용하면 **시퀀스 변환 후 지연 계산 방식**으로 동작한다.
- 중간 연산(`map`, `filter`)은 실제로 데이터를 처리하지 않고, **최종 연산(`toList()`)이 호출될 때 연산이 수행됨**.
- 불필요한 중간 리스트가 만들어지지 않으므로 **메모리 사용량이 줄어들고 성능이 개선됨** 🚀.

---

## ✅ 시퀀스 연산 실행 순서

### 🔹 즉시 실행 vs 지연 실행 비교

아래 코드를 실행하면 연산이 수행되는 순서를 확인할 수 있다.

```kotlin
listOf(1, 2, 3, 4).asSequence()
    .map { print("map($it) "); it * it }
    .filter { print("filter($it) "); it % 2 == 0 }
    .toList()

```

### 🧐 출력 결과

```
map(1) filter(1) map(2) filter(4) map(3) filter(9) map(4) filter(16)

```

### 🔹 즉시 실행과 지연 실행의 차이점

| 방식 | 즉시 실행 방식 (`List`) | 지연 실행 방식 (`Sequence`) |
| --- | --- | --- |
| **연산 방식** | `map` 실행 후 모든 요소 변환 → `filter` 실행 | `map` 실행 후 즉시 `filter` 적용 |
| **중간 컬렉션** | `map` 실행 후 새로운 리스트 생성 | 중간 리스트 없이 연산 수행 |
| **연산 순서** | 모든 요소 변환 후 필터링 | 한 요소씩 변환 후 필터링 |
| **효율성** | 데이터가 많아질수록 불필요한 연산 증가 | 불필요한 연산이 최소화됨 |

🔹 **즉시 실행 방식 문제점**

- `map`이 **모든 요소에 대해 변환을 수행한 후** 새로운 리스트 생성.
- `filter`가 **새로운 리스트를 다시 필터링하면서 추가적인 연산 수행**.
- 중간 결과를 저장하는 리스트가 계속 만들어져 **메모리 낭비 발생** 🚨.

🔹 **지연 실행 방식의 장점**

- `map`과 `filter`가 **각 요소별로 차례로 실행**됨.
- 중간 리스트를 만들지 않고 바로 연산을 수행하여 **메모리 절약 & 성능 향상** 🚀.

---

## ✅ 3.1 `generateSequence`를 이용한 무한 시퀀스 생성

### 🔹 `generateSequence`란?

일반 리스트(`List<Int>`)는 **고정된 크기**를 갖지만, **시퀀스는 필요할 때만 값을 생성하고 사용할 수 있음**.

```kotlin
val naturalNumbers = generateSequence(0) { it + 1 }
val numbersTo100 = naturalNumbers.takeWhile { it < 100 }
println(numbersTo100.sum()) // 5050

```

### 🔹 분석

1. `generateSequence(0) { it + 1 }`
    - 0부터 시작해서 1씩 증가하는 **무한 시퀀스**를 생성.
2. `takeWhile { it < 100 }`
    - `100`보다 작은 숫자까지만 가져옴.
3. `sum()`
    - **최종 연산**이 호출될 때까지 연산이 수행되지 않음.

✔️ **일반 리스트를 사용하면 100개의 요소를 미리 생성해야 하지만, 시퀀스를 사용하면 필요한 만큼만 계산하여 성능이 더 우수하다.** 🚀

---

## ✅ 3.2 디렉터리 탐색에 시퀀스 활용

### 🔹 특정 파일이 숨김 폴더 안에 있는지 확인하기

파일 시스템을 탐색할 때, 특정 파일이 **숨김 폴더 안에 있는지 확인**하고 싶을 수 있다.

이럴 때 **시퀀스를 사용하면 부모 폴더를 하나씩 탐색하며 조건을 만족하는지 검사할 수 있다.**

```kotlin
fun File.isInsideHiddenDirectory(): Boolean =
    generateSequence(this) { it.parentFile }.any { it.isHidden }

val file = File("/Users/svtk/.HiddenDir/a.txt")
println(file.isInsideHiddenDirectory()) // true

```

### 🔹 분석

1. `generateSequence(this) { it.parentFile }`
    - 현재 파일(`this`)에서 **부모 디렉터리를 따라 올라가는 시퀀스**를 생성.
2. `.any { it.isHidden }`
    - 부모 폴더 중 하나라도 숨김 폴더라면 `true` 반환.
    - **숨김 폴더를 찾으면 즉시 탐색 종료** → **불필요한 연산 방지** 🚀.

✔️ **기존 방식처럼 모든 부모 디렉터리를 리스트에 저장할 필요 없이, 조건을 만족하면 바로 탐색을 종료할 수 있다.** 🎯

---

## 🎯 **정리**

| 🚀 즉시 실행 vs 지연 실행 | 즉시 실행 방식 | 지연 실행 방식 |
| --- | --- | --- |
| **연산 방식** | 각 연산이 실행될 때마다 새로운 컬렉션 생성 | 최종 연산이 호출될 때까지 연산이 수행되지 않음 |
| **중간 컬렉션** | 중간 결과를 저장하는 리스트가 계속 생성됨 | 중간 리스트를 만들지 않음 |
| **성능 최적화** | 요소 개수가 많을수록 메모리 낭비 | 필요한 만큼만 연산 수행하여 성능 향상 |
| **사용 예시** | 일반적인 `map`, `filter` | `asSequence()`, `generateSequence()` |

✔️ **즉시 실행 방식은 간단하지만, 데이터가 많아지면 성능이 저하될 수 있음.**

✔️ **시퀀스를 사용하면 중간 컬렉션을 만들지 않고 필요한 만큼만 연산하여 성능이 최적화됨!** 🚀

---

## 🏆 **마무리**

✅ **즉시 실행 방식**은 작은 데이터 처리에는 문제없지만, 큰 데이터에서는 **불필요한 연산이 많아져 성능이 저하**될 수 있음.

✅ **지연 실행 방식**(시퀀스)은 **중간 컬렉션을 만들지 않고 필요할 때만 연산을 수행**하므로 성능이 뛰어남.

✅ `generateSequence`를 활용하면 **무한 시퀀스를 생성**할 수도 있고, **파일 시스템 탐색**에도 활용할 수 있음.

✅ 즉시 실행과 지연 실행을 적절히 선택하면 **더 효율적인 코드를 작성할 수 있음!** 🚀
