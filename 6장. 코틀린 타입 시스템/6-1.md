## 오인성 Part
# 6-1. 널 가능성
**널 가능성(nullability)** 은 프로그램에서 흔히 발생하는 **`NullPointerException(NPE)`** 오류를 방지하도록 설계된 코틀린 타입 시스템의 중요한 특징이다.  
자바에서는 흔히 다음과 같은 메시지로 NPE를 경험하게 된다.

- `"An error has occurred: java.lang.NullPointerException"`
- `"Unfortunately, the application X has stopped"`

이러한 오류는 사용자뿐만 아니라 개발자에게도 혼란을 준다. 코틀린과 같은 최신 언어는 **실행 시점(runtime)** 이 아닌 **컴파일 시점(compile-time)** 에 널 관련 문제를 발견하도록 돕는다. 즉, 타입 시스템에 널 가능성을 명시함으로써, 컴파일러가 잠재적인 NPE를 미리 감지해 오류를 예방할 수 있다.

## 6.1.1 널이 될 수 있는 타입

코틀린과 자바의 중요한 차이점 중 하나는 **널이 될 수 있는 타입(nullable type)** 을 명시적으로 지원한다는 점이다.  
널이 될 수 있는 타입이란, 변수나 프로퍼티가 `null`을 저장할 수 있음을 의미한다.

널이 될 수 있는 타입의 변수에 메서드를 호출하면 **NullPointerException**이 발생할 위험이 있다. 코틀린은 이런 호출을 금지하여 오류를 예방한다.

### 널을 허용하지 않는 함수

다음은 자바로 작성된 문자열 길이를 반환하는 함수이다.

```java
int strLen(String s) {
	return s.length();
}
```

위의 함수는 매개변수 `s`가 null일 경우 NullPointerException이 발생할 수 있다.

코틀린에서는 널을 허용하지 않는 타입으로 아래처럼 정의할 수 있다.

```kotlin
fun strLen(s: String) = s.length
```

이 경우, 널을 전달하면 컴파일 오류가 발생한다.

```kotlin
strLen(null)
// ERROR: Null can not be a value of a non-null type String
```

코틀린에서는 별도의 null 체크 없이도 `strLen` 함수가 절대 NullPointerException을 발생시키지 않는다고 보장할 수 있다.

---

### 널을 허용하는 함수
![](/image/6-1.1.png)

코틀린에서 타입 뒤에 `?`를 붙이면, 그 변수는 널을 허용하는 타입이 된다.  
예를 들어, `String?`, `Int?`, `MyCustomType?`는 모두 null을 저장할 수 있다.

널을 허용하는 함수는 아래와 같이 정의할 수 있다.

```kotlin
fun strLenSafe(s: String?) = ...
```

널이 될 수 있는 타입의 변수로는 직접 메서드를 호출할 수 없다.

```kotlin
fun strLenSafe(s: String?) = s.length()
// ERROR: only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type kotlin.String?
```

---

### 널 가능성에 따른 타입 제약

널이 될 수 있는 값(`String?`)을 널이 될 수 없는 타입(`String`)에 대입하면 오류가 발생한다.

```kotlin
val x: String? = null
val y: String = x
// ERROR: Type mismatch: inferred type is String? but String was expected
```

널 가능 값(`String?`)을 널을 허용하지 않는 함수에 인자로 넘겨도 오류가 발생한다.

```kotlin
strLen(x)
// ERROR: Type mismatch: inferred type is String? but String was expected
```

---

### 널이 될 수 있는 타입을 안전하게 사용하는 방법

널이 될 수 있는 타입은 직접 메서드를 호출할 수 없지만, `null`과 비교하면 이후 안전한 영역에서 널이 될 수 없는 값처럼 사용할 수 있다.

예시:

```kotlin
// if 검사를 통해 null 값 다루기
fun strLenSafe(s: String?): Int = 
	if (s != null) s.length else 0
	
val x: String? = null
println(strLenSafe(x))    // 0 출력
println(strLenSafe("abc")) // 3 출력
```

이렇게 하면 null 값을 안전하게 처리할 수 있다.

## 6.1.2 타입의 의미

타입은 값의 **분류(classification)** 다.  
즉, 타입은 어떤 값이 가능하며, 그 값에 어떤 연산을 수행할 수 있는지 결정한다.

### 자바의 타입 문제점

자바의 `double` 타입을 예로 들어보자.

- `double` 타입은 **64비트 부동소수점 수**를 나타낸다.
- 따라서, 이 타입의 변수라면 일반적인 수학 연산을 수행할 수 있다는 사실을 컴파일 단계에서 알 수 있다.

하지만 `String` 타입의 경우 상황이 다르다.  
자바의 `String` 타입 변수에는 실제 문자열이나 `null`이 들어갈 수 있으며, 둘은 전혀 다른 종류의 값이다.  
즉, 같은 타입임에도 실제 값이 문자열인지 `null`인지에 따라 수행할 수 있는 연산이 달라진다.

이러한 문제는 자바의 타입 시스템이 널(`null`)을 제대로 처리하지 못하기 때문에 발생한다.  
결과적으로 개발자가 변수의 널 여부를 항상 추가적으로 검사해야 하고, 이를 생략하면 실행 시점에 `NullPointerException`이 발생할 수 있다.

### 코틀린의 널 가능 타입

코틀린은 널 가능성 문제를 근본적으로 해결하기 위해 널이 될 수 있는 타입과 널이 될 수 없는 타입을 엄격히 구분한다.

- **널이 될 수 없는 타입(non-nullable)** : 항상 실제 값을 저장한다.
- **널이 될 수 있는 타입(nullable)** : 실제 값 또는 `null`을 저장할 수 있다.

이렇게 두 타입을 명확히 구분하면 각 값에 대해 사용할 수 있는 연산이 명확히 정해지므로, 실행 시점의 오류 가능성을 미리 방지할 수 있다.

> **코틀린의 타입 검사는 컴파일 시점에 이루어진다.**  
> 널 가능 타입이 실행 시점에 별도의 객체로 감싸지거나 래핑되지 않으므로, 별도의 실행 시점 부가 비용이 발생하지 않는다.

## 6.1.3 안전한 호출 연산자: ?.

코틀린에서 가장 유용한 기능 중 하나는 **안전한 호출 연산자** 인 `?.`이다.  
이 연산자는 널(`null`) 검사와 메서드 호출을 한 번에 처리할 수 있게 해준다.
![](/image/6-1.3.png)

예를 들어 다음의 코틀린 코드를 보자.

```kotlin
s?.toUpperCase()
```

이 코드는 자바의 다음 코드와 동일한 동작을 한다.

```kotlin
if (s != null) s.toUpperCase() else null
```

즉, 호출 대상(`s`)이 `null`이 아니라면 일반적인 메서드 호출처럼 동작하며,  
호출 대상이 `null`이면 메서드는 호출되지 않고 결과는 그냥 `null`이 된다.

안전한 호출의 결과는 항상 널이 될 수 있는 타입이다.  
즉, 원본 메서드의 반환 타입이 `String`이더라도, 안전한 호출을 사용하면 반환 타입은 `String?`이 된다.

```kotlin
fun printAllCaps(s: String?) {
	val allCaps: String? = s?.toUpperCase()
	println(allCaps)
}

>>> printAllCaps("abc")
ABC
>>> printAllCaps(null)
null
```

메서드 호출뿐 아니라 프로퍼티를 읽고 쓸 때도 안전한 호출을 사용할 수 있다.

다음은 프로퍼티에 안전한 호출을 사용하는 예제이다.

```kotlin
class Employee(val name: String, val manager: Employee?)

fun managerName(employee: Employee): String? = employee.manager?.name

>>> val ceo = Employee("Da Boss", null)
>>> val developer = Employee("Bob smith", ceo)
>>> println(managerName(developer))
Da Boss
>>> println(managerName(ceo))
null
```

객체 그래프에 널이 될 수 있는 중간 객체가 여러 개 존재할 때는, 안전한 호출을 **연쇄적으로** 사용하면 매우 편리하다.  
아래는 여러 클래스의 중첩된 널 가능성을 안전한 호출 연산자를 사용해 간결하게 처리한 예제다.

```kotlin
class Address(val streetAddress: String, val zipCode: Int, val city: String, val country: String)
class Company(val name: String, val address: Address?)
class Person(val name: String, val company: Company?)

fun Person.countryName(): String {
	val country = this.company?.address?.country
	return if (country != null) country else "unKnown"
}

>>> val person = Person("Dmitry", null)
>>> println(person.countryName())
unKnown
```

자바에서는 복잡하게 중첩된 널 검사가 자주 등장하지만,  
코틀린은 안전한 호출 연산자(`?.`)를 통해 훨씬 간단하고 깔끔한 코드 작성이 가능하다.

## 6.1.4 엘비스 연산자: ?:

![](/image/6-1.4.png)

코틀린은 **널일 경우 대체할 기본값을 간편히 지정할 수 있는** 엘비스 연산자(`?:`)를 제공한다.  

엘비스 연산자는 아래와 같은 형태이다.

```kotlin
fun foo(s: String?) {
    val t: String = s ?: ""
}
```

위 코드에서 `?:`는 다음과 같이 동작한다.

- 좌항의 값을 평가해 **널이 아니면 좌항의 값**을 사용한다.
- 좌항의 값이 **널이면 우항의 값**을 대신 사용한다.

다음 예시를 살펴보자.

```kotlin
fun strLenSafe(s: String?): Int = s?.length ?: 0

>>> println(strLenSafe("abc"))
3
>>> println(strLenSafe(null))
0
```

엘비스 연산자는 **한 줄 표현식**으로 깔끔하게 작성할 수 있다.

```kotlin
// 한 줄 표현 가능
fun Person.countryName() = company?.address?.country ?: "Unknown"
```

---

### `throw`와 함께 엘비스 연산자 활용하기

코틀린에서는 `return`, `throw`와 같은 문장도 **식(expression)** 이다.  
따라서 엘비스 연산자의 우항에 이런 문장도 사용할 수 있어, 더 명확한 코드 작성이 가능하다.

이러한 방식은 특히 **함수의 전제 조건을 검사할 때 유용**하다.

아래는 엘비스 연산자를 활용하여 회사 주소를 인쇄하는 함수의 예시다.

```kotlin
class Address(
    val streetAddress: String,
    val zipCode: Int,
    val city: String,
    val country: String
)

class Company(
    val name: String,
    val address: Address?
)

class Person(
    val name: String,
    val company: Company?
)

fun printShippingLabel(person: Person) {
    val address = person.company?.address
        ?: throw IllegalArgumentException("No address")

    with(address) {
        println(streetAddress)
        println("$zipCode $city, $country")
    }
}

fun main() {
    val address = Address("Elsestr. 47", 80687, "Munich", "Germany")
    val jetbrains = Company("JetBrains", address)
    val person = Person("Dmitry", jetbrains)

    printShippingLabel(person)
    // 출력:
    // Elsestr. 47
    // 80687 Munich, Germany

    printShippingLabel(Person("Alexey", null))
    // 예외 발생:
    // IllegalArgumentException: No address
}
```

이 코드에서 `printShippingLabel` 함수는 다음과 같은 흐름으로 실행된다.

- 모든 정보가 정상적으로 있으면 주소를 출력한다.
- 회사 주소가 없으면 단순히 `NullPointerException`을 발생시키는 대신 **의미 있는 예외를 발생**시킨다.
- 주소가 있는 경우, `with`를 사용하여 주소를 반복적으로 참조하지 않고 간결하게 표현했다.

---

다음 절에서는 자바의 `instanceof` 검사를 대신할 수 있는 **코틀린의 안전한 타입 캐스트 연산자** 를 알아볼 것이다. 이 타입 캐스트 연산자는 주로 엘비스 연산자나 안전한 호출 연산자와 함께 사용된다.

## 6.1.5 안전한 캐스트 : as?

## 6.1.6 널 아님 단언 : !!

## 6.1.7 let 함수

## 6.1.8 나중에 초기화할 프로퍼티

## 6.1.9 널이 될 수 있는 타입 확장

## 6.1.10 타입 파라미터의 널 가능성

## 6.1.11 널 가능성과 자바

## 더 알아보기
코틀린에서는 Null이 아님을 보장? 체크? 하는 함수가 있는데,
바로 **requireNotNull()** 또는 **checkNotNull()** 이다.
<내부 코드 필요>

```requireNotNull(value)``` 값이 널이면 ```IllegalArgumentException``` 예외를 발생시킨다.

``` kotlin
val name: String? = "John"
val nonNullName = requireNotNull(name) { "name은 null일 수 없습니다." }

```
```checkNotNull(value)``` 값이 널이면 ```IllegalStateException``` 예외를 발생시킨다.

``` kotlin
val email: String? = null
val nonNullEmail = checkNotNull(email) { "email은 반드시 있어야 합니다." }
```
둘 다 널이 아님을 명시적으로 보장하고, 널일 경우 명확한 예외를 던지는 데 사용한다.

!! 연산자보다는 위에 두 함수를 사용하는 것을 추천한다.






