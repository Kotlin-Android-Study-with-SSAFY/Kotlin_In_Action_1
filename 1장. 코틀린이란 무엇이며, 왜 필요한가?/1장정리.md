# 오인성 Part
# 1장. 코틀린이란 무엇이며, 왜 필요한가? 정리
## What 코틀린?
-   자바가 사용되는 모든 곳에서 돌아가는 새로운 프로그래밍 언어
-   간결하고 실용적이며 자바 코드와의 상호운용성을 중시
-   자바의 라이브러리를 사용 가능
​
## 코틀린의 주요 특성
### 1\. 자바가 사용되는 모든 곳에서 사용 가능
-   코틀린의 가장 큰 목적은 현재 자바가 사용되고 있는 모든 용도에 적합하면서 더 간결하고 생산적이며 안전한 대체 언어 제공
-   코틀린 JVM
-   코틀린은 **JVM 이외의 환경**에서도 실행될 수 있다.
    -   **Kotlin/Native** -> 네이티브 바이너리로 변환 (예: iOS, Windows, Linux 등)
    -   **Kotlin/JS** -> JavaScript로 변환 (웹 애플리케이션 개발)
​
### 2\. 정적 타입 지정 언어
#### 코틀린은 정적 타입(statically typed) 지정 언어
**정적 타입 지정 언어란?** -> 모든 프로그램 구성 요소의 타입을 컴파일 시점에 알 수 있고 프로그램 안에서 객체의 필드나 메서드를 사용할 때마다 컴파일러가 타입을 검증
**장점**
-   타입 안정성 높음: 타입 에러를 컴파일 시 발견할 수 있어, 타입 관련 런타임 에러를 방지
-   실행 속도 빠름: 컴파일 시 타입이 결정
-   코드 가독성 좋음 + 유지 보수성이 좋음 : 협업이나 유지보수에 유리
이렇게 컴파일러가 문맥을 고려하여 변수 타입을 결정하는 이런 기능을 **타입 추론(Type Inference)**라고 한다.
또한 코틀린은 널(Null)이 될 수 있는 타입을 지원한다.
그렇다면 Null이란?
null은 프로그래밍에서 **아무것도 없는 값**을 의미한다. 즉, 어떤 변수나 객체가 존재하지 않거나 초기화되지 않았음을 나타내는 특별한 값이다. Java / Kotlin 에서는 **null은 참조형 변수에서만 사용 가능**하며, **NullPointerException(NPE)**을 발생시킬 수 있다.
​
### 3\. 함수형 프로그래밍과 객체지향 프로그래밍
코틀린은 객체지향 프로그래밍(OOP)과 함수형 프로그래밍(FP) 또한 지원한다.
그렇다면 객체지향 프로그램밍과 함수형 프로그래밍은 무엇일까?
​
#### 객체지향 프로그래밍(OOP: Object-Oriented Programming)
-   데이터와 데이터를 조작하는 메서드를 하나의 객체(Object)로 묶어서 설계하는 방식
-   현실 세계의 개념을 모델링하여 유지보수와 확장성을 높이는 데 유리함
-   즉, **객체 중심으로 설계** → 유지보수와 확장성이 좋음
​
주요특징
1.  **캡슐화(Encapsulation)**: 데이터(속성)와 이를 다루는 메서드를 하나로 묶음
2.  **상속(Inheritance)**: 기존 클래스를 확장하여 새로운 클래스를 생성
3.  **다형성(Polymorphism)**: 같은 인터페이스를 사용하여 다른 동작을 수행할 수 있음
4.  **추상화(Abstraction)**: 복잡한 내부 구현을 숨기고 중요한 개념만 드러냄
​
#### 함수형 프로그래밍 (FP: Functional Programming)
-   상태(변수)를 변경하지 않고, 순수 함수(Pure Function)를 조합하여 문제를 해결하는 방식
-   불변성(Immutability)을 유지하며, 함수 조합(Composition)을 활용함
-   일급 시민(First-class) 함수(프로그램의 행동을 나타내는 코드 조각)를 일반 값처럼 다룰 수 있으며, 함수를 변수에 저장 및 함수를 인자로 다른 함수에 전달 그리고 함수에서 새로운 함수로 만들어서 반환하는 등 **함수 중심의 프로그래밍 기법**이다.
​
주요 특징
1.  **순수 함수(Pure Function)**: 동일한 입력 → 동일한 출력 (부작용 없음) + 부수 효과 (side effect) 없음을 의미한다.
2.  **고차 함수(Higher-Order Function)**: 함수를 인자로 전달하거나 반환할 수 있음
3.  **불변성(Immutability)**: 상태를 변경하지 않고 새로운 값을 생성하여 반환
4.  **선언형 스타일(Declarative)**: "어떻게"가 아니라 "무엇을" 할 것인지 기술
​
#### 그렇다면 왜 함수형 프로그래밍을 받아들인 것일까?
​
#### 코드의 간결성과 추상화
함수형 프로그래밍을 사용하면 코드가 더 간결하고 직관적으로 작성될 수 있다. 함수는 값처럼 활용될 수 있으며, 이를 통해 **추상화(abstraction)**를 효과적으로 수행할 수 있다. 추상화를 활용하면 코드 중복을 방지하고, 유지보수성을 높일 수 있다.
예를 들어, 특정 조건을 만족하는 사람을 찾는 함수가 필요할 때, 공통 로직을 분리하고 조건만 다르게 설정하면 된다.
```kotlin
fun findAlice() = findPerson { it.name == "Alice" }
fun findBob() = findPerson { it.name == "Bob" }
```
위 코드에서 findPerson 함수는 조건을 람다 식({ it.name == "Alice" })으로 전달받아 활용할 수 있다. 이처럼 함수형 스타일을 활용하면 중복되는 코드를 줄이고 재사용성을 높일 수 있다.
​
#### 안전한 멀티스레딩 (Safe Multithreading)
다중 스레드 환경에서 같은 데이터를 여러 스레드가 변경하면 동기화 문제(예: 경쟁 조건, 데드락)가 발생할 수 있다. 하지만 함수형 프로그래밍에서는 **불변 데이터(immutable data)**와 **순수 함수(pure function)**를 사용하여 이런 문제를 방지한다.
-   **불변 데이터**: 데이터를 변경하지 않고 새로운 데이터를 생성하는 방식
-   **순수 함수**: 외부 상태를 변경하지 않고 입력값에 따라 항상 같은 출력을 반환하는 함수
이러한 특성 덕분에 함수형 스타일을 사용하면 동기화를 위한 복잡한 코드를 작성하지 않아도 되고, 다중 스레드 환경에서도 안정적으로 실행할 수 있다.
​
#### 테스트가 용이함
**부수 효과(side effect)**가 없는 순수 함수는 독립적으로 실행할 수 있으므로, **테스트하기가 쉽다.**  
명령형 프로그래밍에서는 특정 환경(데이터베이스 연결, 전역 상태 등)을 설정해야 올바른 테스트가 가능하지만, 순수 함수는 그런 환경을 신경 쓰지 않고도 단독으로 검증할 수 있다.
​
#### 함수형 프로그래밍을 지원하는 코틀린의 기능
코틀린은 함수형 프로그래밍을 효과적으로 활용할 수 있도록 다양한 기능을 제공한다.
-   **함수 타입 지원**: 함수를 변수처럼 저장하고, 다른 함수의 파라미터로 넘기거나 함수에서 새로운 함수를 반환할 수 있다.
-   **람다 식(Lambda Expression) 지원**: 익명 함수를 간결하게 정의할 수 있다.  
    예: { x: Int, y: Int -> x + y }
-   **데이터 클래스(Data Class)** 지원: 불변 데이터 구조를 쉽게 정의할 수 있다.  
    예: data class Person(val name: String, val age: Int)
-   **코틀린 표준 라이브러리**: 컬렉션을 함수형 스타일로 다룰 수 있는 다양한 API 제공  
    예: map, filter, reduce, fold 등
​
#### 함수형과 객체지향 프로그래밍의 조화
코틀린은 함수형 스타일을 강제하지 않으며, 객체지향 방식과 혼합하여 사용할 수 있다.  
예를 들어, **상태를 직접 변경해야 하는 경우**에는 명령형 스타일을 사용할 수도 있고, **데이터를 조작하는 경우**에는 함수형 스타일을 적용할 수 있다.
> 즉, **문제에 맞는 최적의 방식**을 선택하여 사용할 수 있다는 점이 코틀린의 큰 장점이다.
​
### 4\. 무료 오픈소스 언어
#### 코틀린은 무료 오픈소스 언어
코틀린은 **오픈소스 프로그래밍 언어**로, 누구나 무료로 사용할 수 있다.  
이는 단순히 언어뿐만 아니라 **컴파일러, 표준 라이브러리, 개발 도구** 등 코틀린과 관련된 모든 요소가 오픈소스로 제공됨을 의미한다.
​
#### 라이선스: Apache 2.0
코틀린은 **Apache 2.0 라이선스** 하에 배포된다.  
Apache 2.0 라이선스의 주요 특징:
-   **무료 사용 가능**: 상업적 용도로도 무료 사용 가능
-   **수정 및 배포 가능**: 누구나 코드를 수정하고 배포할 수 있음
-   **저작권 고지 필요**: 원저작자의 라이선스 고지를 유지해야 함
-   **특허 보호 제공**: 사용자가 법적 문제 없이 소프트웨어를 활용할 수 있도록 보장
즉, 기업이나 개인 개발자 모두 부담 없이 코틀린을 활용할 수 있으며, 필요에 따라 직접 개선하여 사용할 수도 있다.
​
#### 오픈소스 개발과 기여
코틀린의 개발은 **GitHub(깃허브)**를 통해 진행되며,  
전 세계 개발자들이 코드 개선과 기능 추가에 기여할 수 있다.  
코틀린 개발 커뮤니티는 활발하게 운영되고 있으며, 개발자들은 버그 리포트, 기능 요청, 코드 기여 등을 할 수 있다.
​
#### 코틀린 개발을 위한 오픈소스 IDE 지원
코틀린을 활용하여 애플리케이션을 개발할 때, 다양한 **오픈소스 통합 개발 환경(IDE)**를 사용할 수 있다.
-   **IntelliJ IDEA Community Edition**
    -   JetBrains에서 제공하는 무료 IDE
    -   코틀린과 가장 잘 통합됨
-   **Android Studio**
    -   구글이 제공하는 공식 안드로이드 개발 도구
    -   코틀린을 기본 지원
-   **Eclipse**
    -   오픈소스 IDE 중 하나
    -   코틀린 플러그인을 추가하면 사용 가능
​
## 코틀린 응용
### 1\. 코틀린을 활용한 서버 프로그래밍
#### 서버 프로그래밍 개요
서버 프로그래밍은 광범위한 개념으로, 다음과 같은 다양한 응용 분야가 포함된다.
-   **웹 애플리케이션**: 브라우저에 HTML 페이지를 반환하는 서버
-   **백엔드 API 서버**: 모바일 애플리케이션과 통신하며 JSON 데이터를 제공하는 서버
-   **마이크로서비스**: 여러 작은 서비스가 RPC 프로토콜을 통해 서로 통신하는 시스템
​
#### 자바와의 상호운용성
기존 서버 애플리케이션 개발에서는 주로 자바를 사용해 왔으며, 다양한 기술과 프레임워크가 발전해왔다.  
새로운 서버 애플리케이션을 개발할 때 완전히 새롭게 구축하기보다는 기존 시스템과의 **통합 및 확장**이 중요하다.
코틀린은 자바와 완벽한 **상호운용성**을 제공하므로 기존 자바 기반 시스템을 코틀린으로 확장하거나 변환하는 데 매우 적합하다.
-   기존 **자바 클래스를 코틀린으로 확장** 가능
-   **애노테이션(annotation)** 적용 문제 없음
-   **더 간결한 코드와 높은 유지보수성** 제공
​
#### 코틀린의 DSL 활용
코틀린의 **빌더 패턴(Builder Pattern)**을 활용하면, 간결한 문법으로 객체 그래프를 생성하면서도 추상화와 코드 재사용성을 극대화할 수 있다.
예를 들어, HTML 페이지를 생성하는 코드를 DSL로 표현할 수 있다.
```kotlin
fun renderPersonList(persons: Collection<Person>) = 
    createHTML().table {
        for(person in persons) {
            tr {
                td { +person.name }
                td { +person.age }
            }
        }
    }
```
​
**장점**:
-   HTML을 생성하는데 별도의 템플릿 언어가 필요 없음
-   **코틀린의 일반적인 기능(루프, 변수, 함수)을 그대로 활용** 가능
-   **타입 검사 지원**으로 오류를 줄일 수 있음
​
#### 코틀린 기반 영속성 프레임워크 (Exposed)
데이터베이스 작업에서도 코틀린 DSL을 활용할 수 있다.  
Exposed는 SQL 데이터베이스를 타입 안전하게 다룰 수 있도록 하는 코틀린 DSL 기반 프레임워크다.
```kotlin
object CountryTable : IdTable() { 
    val name = varchar("name", 250).uniqueIndex()
    val iso = varchar("iso", 2).uniqueIndex()
}
​
class Country(id: EntityId) : Entity(id) { 
    var name: String by CountryTable.name
    var iso: String by CountryTable.iso
}
​
val russia = Country.find { 
    CountryTable.iso.eq("ru")
}.first()
​
println(russia.name)
```
​
**장점**:
-   **SQL을 안전하게 작성**할 수 있음 (타입 검사를 통해 오류 방지)
-   **코틀린 코드만으로 데이터베이스 모델링 및 질의 가능**
-   기존 SQL 기반 ORM보다 **더 직관적인 코드 작성 가능**
​
### 2\. 코틀린을 활용한 안드로이드 프로그래밍
#### 모바일 애플리케이션의 특성
-   엔터프라이즈 애플리케이션보다 **코드 크기가 작고 유지보수가 용이**해야 함
-   **다양한 디바이스를 지원**해야 하며, 빠른 배포 주기를 가짐
-   기존 코드와의 **통합이 적은 경우가 많아 새로운 기술을 적극적으로 도입 가능**
​
#### 코틀린과 안드로이드의 생산성 향상
코틀린은 안드로이드 개발 생산성을 높이는 다양한 기능을 제공한다.
-   **리스너 추가 및 UI 요소 바인딩을 간소화**
-   **Jetpack Compose**를 활용한 선언형 UI 개발 지원
-   **코드 자동 생성 기능 활용**으로 반복 작업 감소
​
코틀린 DSL을 활용하면 UI 코드도 간결하게 작성할 수 있다.
```kotlin
verticalLayout {
    val name = editText()
    button("Say Hello") {
        onClick { toast("Hello, ${name.text}!") }
    }
}
```
​
**장점**:
-   **XML 레이아웃 없이 선언형 UI 개발 가능**
-   **코틀린 언어의 기능(람다, 변수, 제어문)과 자연스럽게 결합 가능**
-   **레이아웃과 코드 간 결합을 줄여 유지보수성 향상**
​
#### 안정성과 널 안정성(Null Safety)
안드로이드 애플리케이션에서 가장 흔한 오류 중 하나는 **NullPointerException(NPE)**이다.  
이는 앱이 중단되는 주요 원인이며, "앱이 응답하지 않습니다(ANR)" 오류를 초래할 수 있다.
코틀린의 **Null Safety** 시스템은 이러한 문제를 방지한다.
-   **null이 가능한 변수와 불가능한 변수를 명확하게 구분**
-   **컴파일 타임에서 null 관련 오류 감지 가능**
-   **안정적인 앱 개발 가능**
예를 들어, 자바에서는 null 값을 다룰 때 항상 예외 처리가 필요하지만,  
코틀린에서는 ?. (안전 호출 연산자)나 !! (널 강제 처리) 등을 활용하여 보다 안전하게 코드를 작성할 수 있다.
​
#### 성능 및 호환성
-   **자바 8을 기본적으로 지원**하며, 자바 9~17까지도 호환됨
-   기존 자바 코드와 완벽한 **상호운용성 제공**
-   **런타임 크기가 작아 앱 크기 증가가 최소화됨**
-   **람다 인라이닝(Inlining) 최적화**로 불필요한 객체 생성 방지 → **가비지 컬렉션 비용 절감**
​
## 코틀린 철학
### 실용성 (Pragmatism)
#### 1\. 실질적인 문제 해결을 위한 언어
코틀린은 학문적인 연구를 위한 언어가 아니라, **실제 소프트웨어 개발에서 직면하는 문제를 해결하기 위해 설계된 실용적인 언어**이다.
-   IT 업계에서 **대규모 시스템을 개발한 경험**을 바탕으로 설계됨
-   초기 사용자의 **피드백을 반영**하여 개선됨
-   개발자가 **쉽게 배우고 적용할 수 있도록** 설계됨
​
코틀린은 **혁신적인 아이디어를 실험하는 언어가 아니라**, 이미 **검증된 기능**을 도입하여 **안정적이고 배우기 쉬운 언어**를 목표로 한다.
​
#### 2\. 특정 패러다임 강요 없음
코틀린은 특정한 프로그래밍 스타일을 강요하지 않는다.  
처음에는 **자바와 비슷한 방식**으로 코딩할 수 있으며, 점진적으로 코틀린의 강력한 기능을 익히면서 더 간결한 코드 작성을 할 수 있다.
​
#### 3\. 강력한 개발 도구 지원
코틀린은 **언어 자체뿐만 아니라 개발 도구의 편리성**도 중요하게 고려한다.
​
-   JetBrains의 **IntelliJ IDEA**와 함께 개발되었으며, **강력한 IDE 지원**을 제공
-   **자동 코드 수정 기능**을 통해 개발자가 코틀린의 간결한 문법을 쉽게 배울 수 있음
-   코드 패턴을 **자동으로 감지 및 변환**하여 유지보수성을 높임
​
### 간결성 (Conciseness)
#### 1\. 코드 유지보수를 위한 간결함
코드를 작성하는 시간보다 **읽고 유지보수하는 시간이 더 길다**.  
코드가 간결할수록:
​
-   **버그 수정이 쉬워지고**
-   **이해하기 쉬우며**
-   **협업이 수월해진다**
​
코틀린은 **의미 없는 코드 작성 부담을 줄이고**, **가독성을 높이기 위해 많은 노력을 기울였다.**
​
#### 2\. 반복적인 코드 제거
자바에서는 **반복적인 코드가 많아지는 경우가 많지만**,  
코틀린에서는 **불필요한 코드를 자동으로 처리하는 기능**이 제공된다.
​
✔ **예: 생성자 및 게터/세터 자동 처리**
```java
// 자바 스타일
class Person {
    private String name;
    
    public Person(String name) {
        this.name = name;
    }
    
    public String getName() {
        return name;
    }
}
```
```kotlin
// 코틀린 스타일 (간결함)
class Person(val name: String)
```
-   **코틀린에서는 한 줄로 표현 가능**
-   **게터/세터 자동 생성**
-   **불필요한 반복 코드 제거**
​
#### 3\. 라이브러리 함수 활용
컬렉션에서 데이터를 찾는 것과 같은 일반적인 작업을 수행할 때,  
자바에서는 복잡한 반복문을 사용해야 하지만 코틀린에서는 간단한 **표준 라이브러리 함수**를 사용할 수 있다.
```java
// 자바 스타일
for (Person p : persons) {
    if (p.name.equals("Alice")) {
        return p;
    }
}
return null;
```
```kotlin
// 코틀린 스타일
persons.find { it.name == "Alice" }
```
-   **코드가 간결하고 가독성이 높아짐**
-   **일반적인 패턴을 라이브러리 함수로 캡슐화**
​
#### 4\. 람다 표현식 지원
코틀린은 **람다 표현식**을 지원하여 코드 블록을 쉽게 전달할 수 있다.
```kotlin
list.filter { it.length > 3 }.map { it.uppercase() }
```
**장점**:
-   **더 적은 코드로 복잡한 연산 수행 가능**
-   **불필요한 보일러플레이트 코드 제거**
-   **가독성과 유지보수성 향상**
​
#### 5\. 코드 길이를 줄이는 것이 목표는 아님
코틀린은 **무조건 짧은 코드가 좋은 코드라고 생각하지 않는다.**
-   예를 들어 **연산자 오버로딩**을 지원하지만, 프로그래머가 임의의 연산자를 정의할 수 없도록 제한함
-   **명확성을 유지하면서도 코드가 간결하게 유지될 수 있도록 설계**
​
### 안정성 (Safety)
#### 프로그래밍 언어의 안정성이란?
안정성이 높은 프로그래밍 언어는 프로그램에서 발생할 수 있는 **일부 오류를 원천적으로 방지**한다.
-   하지만 **모든 오류를 막을 수는 없음**
-   안정성을 높이려면 코드에 더 많은 정보를 추가해야 하며, \*\*생산성과의 트레이드오프(Trade-off)\*\*가 존재
​
코틀린은 **자바보다 더 높은 안정성을 제공하면서도, 개발자가 부담해야 하는 비용을 최소화**하는 것이 목표다.
​
#### JVM 기반의 안정성
코틀린은 **JVM에서 실행되는 정적 타입 지정 언어**이므로, 다음과 같은 안정성을 보장한다.
-   **메모리 안정성 보장**
-   **버퍼 오버플로 방지**
-   **잘못된 메모리 접근 오류 방지**
​
#### 타입 안정성 (Type Safety)
자바보다 **더 적은 비용으로** 타입 안정성을 제공한다.
-   대부분의 경우 **코틀린 컴파일러가 타입을 자동 추론**하므로, 직접 타입을 명시할 필요 없음
​
#### 컴파일 시점 오류 방지
코틀린은 **NullPointerException(NPE)**을 방지하기 위해 노력한다.
-   **null 가능 여부를 명확하게 표현할 수 있도록 타입 시스템을 설계**
-   실행 시점 오류 대신 **컴파일 시점에 오류를 감지**
```kotlin
val s: String? = null // <- 널이 될 수 있음
val s2: String = "" // <- 널이 될 수 없음
```
​
**장점**:
-   ? 한 글자만 추가하면 **null 가능성을 쉽게 표현**할 수 있음
-   **NullPointerException(NPE)을 원천적으로 방지**하여 앱 충돌을 줄일 수 있음
​
또한, **null을 다룰 수 있는 편리한 연산자(안전 호출 ?.)를 제공**하여,  
NullPointerException이 발생할 가능성을 더욱 줄인다.
​
#### ClassCastException 방지
타입 변환 시 **ClassCastException**이 발생하는 것을 막기 위해,  
**코틀린에서는 타입 검사와 캐스트를 한 번에 수행**할 수 있다.
​
```kotlin
if (value is String) // 타입을 검사한다.
    println(value.toUpperCase()) // 해당 타입의 메서드를 사용한다.
```
​
**장점**:
-   **타입 검사 후 별도의 캐스트 없이 안전하게 사용 가능**
-   **타입 검사를 생략할 이유가 없어 안정성이 향상됨**
​
### 상호운용성 (Interoperability)
#### 기존 자바 라이브러리 활용 가능
자바 프로그래머들이 가장 궁금해하는 점:  
**"기존 자바 라이브러리를 그대로 사용할 수 있는가?"**  
**코틀린에서는 당연히 가능하다.**
**자바와의 완벽한 상호운용성 제공**:
-   자바 메서드 호출 가능
-   자바 클래스를 상속 가능
-   자바 인터페이스 구현 가능
-   자바 애너테이션 적용 가능
​
#### 자바에서 코틀린 코드 호출 가능
​
**다른 JVM 언어들과 달리**,  
코틀린은 **자바 코드에서 코틀린 코드를 호출할 때도 별도의 설정이 필요 없다.**
-   **자바 프로젝트에 자연스럽게 코틀린을 추가 가능**
-   **코틀린 코드를 추가해도 기존 자바 코드를 수정할 필요 없음**
​
#### 자바 코드를 코틀린으로 변환 가능
코틀린을 도입할 때, 기존 자바 코드를 **코틀린 코드로 변환하는 도구**를 활용할 수 있다.
-   **기존 코드의 역할과 무관하게 코틀린 코드로 변환 가능**
-   **변환된 코틀린 코드가 프로젝트 내 다른 코드와 문제없이 작동**
​
#### 기존 자바 라이브러리 활용 극대화
코틀린은 자체 컬렉션 라이브러리를 제공하지 않고, **자바 표준 라이브러리를 적극 활용**한다.  
다만, **사용성을 개선하기 위해 몇 가지 확장 기능을 추가**했을 뿐이다.
​
**장점**:
-   기존 자바 API를 그대로 사용할 수 있음
-   **별도의 변환 과정 없이 자바 라이브러리를 활용할 수 있음**
-   **성능 저하 없이 실행됨 (추가적인 런타임 비용 없음)**
​
#### 다중 언어 프로젝트 지원
코틀린은 **자바와 코틀린이 혼합된 프로젝트도 완벽히 지원**한다.  
즉, **자바와 코틀린 소스 파일이 섞여 있어도 문제없이 컴파일 가능**
​
**IDE에서 제공하는 기능**:
-   **자바 ↔ 코틀린 코드 간 내비게이션 가능**
-   **다중 언어 프로젝트 디버깅 지원**
-   **자바 메서드를 리팩토링하면 관련된 코틀린 코드까지 자동 수정됨**
​
## 코틀린 도구 사용
### 코틀린은 컴파일 언어
코틀린은 **자바와 마찬가지로 컴파일 언어**이므로, 실행 전에 코드를 컴파일해야 한다.  
\-> 코틀린 소스 코드는 **컴파일러(kotlinc)를 통해 바이트코드(.class 파일)로 변환**된다.  
\-> 변환된 바이트코드는 **JVM(Java Virtual Machine)에서 실행 가능**하다.
​
### 코틀린 코드 컴파일 과정
코틀린 소스 코드를 저장할 때는 **.kt 확장자**를 사용한다.  
컴파일 과정은 다음과 같다.
​![코틀린 코드 컴파일 과정](https://github.com/user-attachments/assets/e64cf4c7-078d-4033-a87f-3ea0375465d7)


1\. **코틀린 컴파일러(kotlinc) 실행**
-   .kt 파일을 .class 파일로 변환
-   표준 패키징 과정을 거쳐 실행 가능하도록 준비
​
2\. **컴파일된 .class 파일 실행**
-   Java 명령어를 사용하여 실행 가능
​
**명령어 실행 예제**
```sh
# 코틀린 코드 컴파일 (JAR 파일 생성)
kotlinc <소스코드 또는 디렉터리> -include-runtime -d <jar 이름>
​
# 컴파일된 JAR 파일 실행
java -jar <jar 이름>
```
​
**결과물**:
-   **.class 파일이 생성되며, 이를 표준 JAR 패키지로 배포 가능**
-   **자바와 동일한 방식으로 실행할 수 있음**
​
### 코틀린 런타임 라이브러리
-   코틀린 코드가 실행되려면 **코틀린 런타임 라이브러리**가 필요하다.
-   **표준 라이브러리 클래스 + 자바 API 확장 기능**이 포함되어 있음.
-   **배포 시 코틀린 런타임 라이브러리도 함께 포함해야 함.**
​
### 빌드 시스템과 호환성
실제 프로젝트에서는 **메이븐(Maven), 그레이들(Gradle), 앤트(Ant)와 같은 빌드 시스템**을 사용하여 컴파일한다.
-   코틀린은 이러한 빌드 시스템과 완벽하게 호환됨
-   코틀린과 자바 코드가 함께 있는 프로젝트도 지원
-   메이븐과 그레이들은 코틀린 런타임을 자동으로 포함하여 패키징
